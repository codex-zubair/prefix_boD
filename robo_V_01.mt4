//+------------------------------------------------------------------+
//|                                                   test_robot.mq4 |
//|                                  Copyright 2024, MetaQuotes Ltd. |
//|                                             https://www.mql5.com |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024, MetaQuotes Ltd."
#property link      "https://www.mql5.com"
#property version   "1.00"
//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
#property strict


int zag_counter = 0;
int zig_counter = 0;
int zag_change_checker = 0;
int zig_change_checker = 0;

int up_staying_same = 0;
int down_staying_same = 0;

int n = 0;
double zag, zig;


//AVERAGE MOVE VALUE CALCULATOR
double up_current_average = 0;  // Current average value
//int up_total_new_value = 0;                     // Number of values contributing to current average
double up_new_value = 0;        // New value to be added
double up_new_average;



double down_current_average = 0;  // Current average value
//int up_total_new_value = 0;                     // Number of values contributing to current average
double down_new_value = 0;        // New value to be added
double down_new_average;
//AVERAGE MOVE VALUE CALCULATOR


double prevA = 0.00;
double prevB = 0.00;



//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
  {
//---
   EventSetTimer(2);
//---
   
   return(INIT_SUCCEEDED);
  }
//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
  {
//---
      
    
   
  }
//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
  {
  
    int n = 0;
    
    // First zigzag
    int i = 0;
    while (n < 2)
    {
        if (zag > 0)
            zig = zag;
        
        zag = iCustom(NULL, 0, "ZigZag", 0, i);
        
        if (zag > 0)
            n++;
        
        i++;
    }

  }
  
  
void PlaceBuyOrder()
{
    double lotSize = 1.0; // Volume of the order
    double price = SymbolInfoDouble(_Symbol, SYMBOL_ASK); // Current ask price
    
    int cmd = OP_BUY; // Order type (OP_BUY for buy orders)
    double volume = lotSize;
    double openPrice = price;
    int slippage = 3; // Maximum allowed slippage
    int magicNumber = 0; // Optional, used to distinguish orders from different Expert Advisors

    double stopLoss = NormalizeDouble(price - 50 * Point, Digits); // Example: setting stop loss 50 pips below the current price
    double takeProfit = NormalizeDouble(price + 100 * Point, Digits); // Example: setting take profit 100 pips above the current price

    int ticket = OrderSend(_Symbol, cmd, volume, openPrice, slippage, stopLoss, takeProfit, NULL, magicNumber, 0, clrNONE);

    if(ticket > 0)
    {
        Print("Buy order placed successfully. Ticket: ", ticket);
    }
    else
    {
        int error = GetLastError();
        Print("Failed to place buy order. Error code: ", error);
    }
}



void OnTimer()
{
    
    Print("order placed");
    zag_counter++;
    zig_counter++;  
    
 
    
if(OrdersTotal()== 0)
   {

      //PlaceBuyOrder();
          // Call the functions sequentially
      
      
      
      //---------------------------------------------
         //SWAPPING VALUES TO KEEP ALWAYS BIG
      //---------------------------------------------
      // Check if swap is needed
   if(zig < zag)
     {
      // Swap values
      int temp = zig;
      zig = zag;
      zag = temp;
     }

   // Ensure ZIG is always bigger than ZAG
   if(zig < zag)
     {
      // Swap values again to fix the condition
      int temp = zig;
      zig = zag;
      zag = temp;
     }
      
     //---------------------------------------------
         //SWAPPING VALUES TO KEEP ALWAYS BIG
     //---------------------------------------------    
      
      
      
    
      
      Print("5_M_DOWN: ",zag," 5_M_UP: ", zig);
      
      
      // After 10 seconds it will check it has changed or not.
      if(zag != prevB)
        {
           Print("Donw not same");
           Print("i'm counting for Dwon: ", zag_counter);
           
           if(zag_counter >= 10)
            {
               
               zag_counter = 0;
               Print("Counter becomes zero!");
               prevB = zag;
               zag_change_checker++;
               
            }
        }
        // 1.08287 5_M_UP: 1.08545

        
      else if (zag == prevB)
        {
           down_staying_same++;
           Print("Down staying same: " , down_staying_same);
           Print("Down equal now!");
           Print("Down_change Checker: ",zag_change_checker);
           
            //---------------------------------------------
            // Calculate new average
            down_new_average = ((down_current_average * zig_change_checker) + down_staying_same) / (zig_change_checker + 1);
            Print("DOWN New Average value: ", NormalizeDouble(down_new_average, 2));
            // Calculate new average
            //---------------------------------------------
            
            
            
            // ========UP DOWN diffarence========
            // Subtract the value
            double result = down_new_average - up_new_average;

            // Take the absolute value to ensure it's positive
            double absoluteResult = MathAbs(result);

            // Round the absolute value to the nearest integer
            double roundedResult = NormalizeDouble(absoluteResult, 0);
            Print("Diffarences:- ", roundedResult);
            // ========Up DOWN diffarences=========
            
        }
        
        
        
        
        
       
        
      
        // After 20 Second it will check it has changed or not   
        if(zig != prevA)
          {
           Print("UP not same");
           Print("i'm counting for UP: ", zig_counter);
           
         if(zig_counter >= 20)
            {
               zig_counter = 0;
               Print("UP Counter becomes zero!");
               prevA = zig;
               zig_change_checker++;
               
            }
          
          }
          else if (zig == prevA)
          {
            up_staying_same++;
            Print("UP staying same:" , up_staying_same);
            Print("UP equal now!");
            Print("Up_change Checker: ",zig_change_checker);
            //---------------------------------------------
            // Calculate new average
            up_new_average = ((up_current_average * zig_change_checker) + up_staying_same) / (zig_change_checker + 1);
            Print("UP New Average value: ", NormalizeDouble(up_new_average, 2));
            // Calculate new average
            //---------------------------------------------

          }  
          
        

   }
}




//+------------------------------------------------------------------+
